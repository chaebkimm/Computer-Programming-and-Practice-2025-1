# 키보드에서 1바이트씩 입력받기

## 할 일

* 다음 소스 코드들 중에 개발 환경에 적절한 코드를 선택해서 실행해보세요.

* 실행시 키보드에서 a키, z키, 0키, 9키, A키, Z키, 탭키, 엔터키, 왼쪽화살표키, Esc키, q키를 누른 후,
  화면에 출력되는 결과를 확인해보세요.

## 제출할 내용

* 개발 환경 정보를 제출해주세요

* 실행 결과를 복사 붙여넣기 해서 제출해주세요

## 소스 코드

### 운영체제: 윈도우, C 라이브러리: Universal C Runtime, Microsoft Visual C++ Runtime Library
#### 해당 개발 환경:
* Visual Studio. VSCode에서 실행시 Run C/C++ File에서 C/C++: cl.exe build ... (compiler: cl.exe)
* MSYS2의 UCRT64 환경에서 설치한 mingw-w64-ucrt-x86_64-gcc. VSCode에서 실행시 Run C/C++ File에서 C/C++: gcc.exe build ... (compiler: C:\msys64\ucrt64\bin\gcc.exe)
* MSYS2의 MINGW64 환경에서 설치한 mingw-w64-x86_64-gcc. VSCode에서 실행시 Run C/C++ File에서 C/C++: gcc.exe build ... (compiler: C:\msys64\mingw64\bin\clang.exe)
* MSYS2의 CLANG64 환경에서 설치한 mingw-w64-clang-x86_64-gcc. VSCode에서 실행시 CodeLLDB extension 설치 후 [CodeLLDB 매뉴얼](https://github.com/vadimcn/codelldb/blob/v1.11.4/MANUAL.md#starting-a-new-debug-session)에 따라 실행

```c
#include <stdio.h>
#include <conio.h>

/* get 1 byte data from keyboard input without enter */
unsigned char get_byte();

/* our main function to work with is named as new_main */
int new_main() {
  unsigned char ch_input; /* a byte from keyboard input */
  int count = 0; /* how many times get_byte() was called */

  do {
    ch_input = get_byte();
    printf("%d: [%3d, 0x%02x] '%c'\n", count++, ch_input, ch_input, ch_input);
  } while(ch_input != 'q');

  return 0;
}

/* configure terminal. currently do nothing. */
int setup_terminal() { return 0; }

/* restore initial terminal configuration. currently do nothing. */
int reset_terminal() { return 0; }

/* In main function, first setup terminal, then run our new_main. restore terminal before return. */
int main() {
  setup_terminal();
  new_main();
  reset_terminal();
}

/* get 1 byte data from keyboard input without enter */
unsigned char get_byte() {
  return (unsigned char)_getch();
}
```

### 운영체제: 윈도우, C 라이브러리: Cygwin
#### 해당 개발 환경:
* MSYS2의 MSYS 환경에서 설치한 gcc. VSCode에서 실행시 Run C/C++ File에서 C/C++: gcc.exe build ... (compiler: C:\msys64\usr\bin\gcc.exe)
```c
#include <stdio.h>
#include <sys/termios.h>

/* get 1 byte data from keyboard input without enter */
unsigned char get_byte();

/* our main function to work with is named as new_main */
int new_main() {
  unsigned char ch_input; /* a byte from keyboard input */
  int count = 0; /* how many times get_byte() was called */

  do {
    ch_input = get_byte();
    printf("%d: [%3d, 0x%02x] '%c'\n", count++, ch_input, ch_input, ch_input);
  } while(ch_input != 'q');

  return 0;
}





/* save terminal configuration to the termios struct */
int get_terminal_setting(struct termios *pointer_to_setting) {
  int stdin_fileno = fileno(stdin);
  int error_no = tcgetattr(stdin_fileno, pointer_to_setting);

  if (error_no) {
    printf("Error: tcgetattr, error_no is %d.\n", error_no);
    return 1;
  }
  return 0;
}


/* update terminal configuration from the termios struct*/
int set_terminal_setting(struct termios *pointer_to_setting) {
  int stdin_fileno = fileno(stdin);
  int error_no = tcsetattr(stdin_fileno, TCSANOW, pointer_to_setting);
  if (error_no) {
    printf("Error: tcsetattr, error_no is %d.\n", error_no);
    return 1;
  }
  return 0;
}  


/* configure terminal for noncanonical input (one byte each time) and no echo */
int setup_terminal() { 
  struct termios terminal_setting;
  int error_no = get_terminal_setting(&terminal_setting);

  if (error_no) return 1;

  terminal_setting.c_lflag &= ~ICANON;
  terminal_setting.c_lflag &= ~ECHO;

  error_no = set_terminal_setting(&terminal_setting);

  if (error_no) return 1;
  return 0;
}


/* restore initial terminal configuration (canonical input: after enter key, set echo). */
int restore_terminal() {
  struct termios terminal_setting;
  int error_no = get_terminal_setting(&terminal_setting);

  if (error_no) return 1;

  terminal_setting.c_lflag |= ICANON;
  terminal_setting.c_lflag |= ECHO;

  error_no = set_terminal_setting(&terminal_setting);

  if (error_no) return 1;
  else return 0;
}


/* In main function, first setup terminal, then run our new_main. restore terminal before return. */
int main() {
  setup_terminal();
  new_main();
  reset_terminal();
}


/* get 1 byte data from keyboard input without enter */
unsigned char get_byte() {
  unsigned char ch_input;
  scanf("%c", &ch_input);
  return ch_input;
}

```


### 운영체제: Linux, C 라이브러리: glibc
### 운영체제: macOS, C 라이브러리: libSystem
#### 해당 개발 환경:
* Windows Subsystem for Linux
* Ubuntu
* Redhat
* macOS
* VMware로 구현된 리눅스 또는 맥OS

```c
#include <stdio.h>
#include <termios.h>

/* get 1 byte data from keyboard input without enter */
unsigned char get_byte();

/* our main function to work with is named as new_main */
int new_main() {
  unsigned char ch_input; /* a byte from keyboard input */
  int count = 0; /* how many times get_byte() was called */

  do {
    ch_input = get_byte();
    printf("%d: [%3d, 0x%02x] '%c'\n", count++, ch_input, ch_input, ch_input);
  } while(ch_input != 'q');

  return 0;
}





/* save terminal configuration to the termios struct */
int get_terminal_setting(struct termios *pointer_to_setting) {
  int stdin_fileno = fileno(stdin);
  int error_no = tcgetattr(stdin_fileno, pointer_to_setting);

  if (error_no) {
    printf("Error: tcgetattr, error_no is %d.\n", error_no);
    return 1;
  }
  return 0;
}


/* update terminal configuration from the termios struct*/
int set_terminal_setting(struct termios *pointer_to_setting) {
  int stdin_fileno = fileno(stdin);
  int error_no = tcsetattr(stdin_fileno, TCSANOW, pointer_to_setting);
  if (error_no) {
    printf("Error: tcsetattr, error_no is %d.\n", error_no);
    return 1;
  }
  return 0;
}  


/* configure terminal for noncanonical input (one byte each time) and no echo */
int setup_terminal() { 
  struct termios terminal_setting;
  int error_no = get_terminal_setting(&terminal_setting);

  if (error_no) return 1;

  terminal_setting.c_lflag &= ~ICANON;
  terminal_setting.c_lflag &= ~ECHO;

  error_no = set_terminal_setting(&terminal_setting);

  if (error_no) return 1;
  return 0;
}


/* restore initial terminal configuration (canonical input: after enter key, set echo). */
int reset_terminal() {
  struct termios terminal_setting;
  int error_no = get_terminal_setting(&terminal_setting);

  if (error_no) return 1;

  terminal_setting.c_lflag |= ICANON;
  terminal_setting.c_lflag |= ECHO;

  error_no = set_terminal_setting(&terminal_setting);

  if (error_no) return 1;
  else return 0;
}


/* In main function, first setup terminal, then run our new_main. restore terminal before return. */
int main() {
  setup_terminal();
  new_main();
  reset_terminal();
}


/* get 1 byte data from keyboard input without enter */
unsigned char get_byte() {
  unsigned char ch_input;
  scanf("%c", &ch_input);
  return ch_input;
}

```
